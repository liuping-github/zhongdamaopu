{"version":3,"sources":["index.js","geo/index.js","geo/point.js","validate.js","constant.js","util.js","serverDate/index.js","helper/symbol.js","utils/symbol.js","utils/type.js","geo/lineString.js","geo/polygon.js","geo/multiPoint.js","geo/multiLineString.js","geo/multiPolygon.js","collection.js","document.js","serializer/datatype.js","commands/update.js","query.js","serializer/query.js","commands/query.js","commands/logic.js","operator-map.js","serializer/common.js","serializer/update.js","aggregate.js","utils/utils.js","command.js","regexp/index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AFMA,AFMA,AKfA,AFMA;ACFA,AFMA,AFMA,AKfA,AFMA;ACFA,AFMA,AFMA,AKfA,AFMA;ACFA,AFMA,AFMA,AMlBA,ADGA,AFMA;ACFA,AFMA,AFMA,AMlBA,ADGA,AFMA;ACFA,AFMA,AFMA,AMlBA,ADGA,AFMA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AFMA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AFMA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AFMA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AGTA,ALeA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AGTA,ALeA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AGTA,ALeA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AFMA,AKfA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AKfA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AKfA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AKfA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AS3BA,AJYA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AS3BA,AJYA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AS3BA,AJYA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AENA,AV8BA,AS3BA,AJYA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AENA,AV8BA,AS3BA,AJYA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AENA,AV8BA,AS3BA,AJYA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AV8BA,AS3BA,AJYA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AV8BA,AS3BA,AJYA,APqBA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AV8BA,AS3BA,AXiCA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AMlBA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AMlBA,ADGA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AMlBA,ADGA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AMlBA,ADGA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AKfA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AKfA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AKfA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AKfA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AiBnDA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AiBnDA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AiBnDA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AiBnDA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AiBnDA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AiBnDA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AmBzDA,AFMA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AmBzDA,AFMA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AmBzDA,AFMA,AZoCA,AGTA,ACHA,ANkBA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AGTA,ACHA,ANkBA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AGTA,ALeA;AYnCA,AGTA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AGTA,ALeA;AYnCA,AMlBA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AGTA,ALeA;AYnCA,AMlBA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AFMA;AYnCA,AMlBA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AmBzDA,AFMA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AuBrEA,AJYA,AFMA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AuBrEA,AJYA,AFMA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AuBrEA,AJYA,AFMA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AuBrEA,AJYA,AKfA,APqBA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AuBrEA,AJYA,AKfA,APqBA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AXiCA,AuBrEA,AJYA,AKfA,APqBA,AGTA,Af6CA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AYnCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AXiCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AXiCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AXiCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AXiCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AOrBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AYpCA,AJYA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AXiCA,AavCA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,ANkBA,AGTA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,AHSA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,AHSA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,AHSA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,AHSA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,AHSA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AHSA,Ad0CA,AYpCA,AHSA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AHSA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AHSA,ACHA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AHSA,AQxBA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AFMA,AKfA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,AjBmDA,AYpCA,AGTA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AsBlEA,AxBwEA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AU9BA,ALeA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,APqBA,AGTA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA,AFMA;AuBpEA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA,ApB4DA;AqB9DA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,AKfA,AJYA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,ANkBA,ADGA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,APqBA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,APqBA,ALeA,AGTA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,APqBA,AFMA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;ACFA,AENA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA,AKfA;AGRA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;AQvBA,AT2BA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Geo = require(\"./geo/index\");\nconst collection_1 = require(\"./collection\");\nconst command_1 = require(\"./command\");\nconst index_1 = require(\"./serverDate/index\");\nconst index_2 = require(\"./regexp/index\");\nconst bson_1 = require(\"bson\");\nvar query_1 = require(\"./query\");\nexports.Query = query_1.Query;\nvar collection_2 = require(\"./collection\");\nexports.CollectionReference = collection_2.CollectionReference;\nvar document_1 = require(\"./document\");\nexports.DocumentReference = document_1.DocumentReference;\n/**\n * 数据库模块\n *\n */\nclass Db {\n    constructor(config) {\n        var _a;\n        /**\n         * Geo 类型\n         */\n        this.Geo = Geo;\n        /**\n         * 逻辑操作的命令\n         */\n        this.command = command_1.Command;\n        /**\n         * This method was deprecated, use js native `new RegExp()` instead\n         * @deprecated\n         */\n        this.RegExp = index_2.RegExpConstructor;\n        /**\n         * This method is deprecated, not implemented in server side\n         * @deprecated\n         */\n        this.serverDate = index_1.ServerDateConstructor;\n        if (!config.request) {\n            throw new Error('DbConfig.request cannot be empty');\n        }\n        this.request = config.request;\n        this.primaryKey = (_a = config.primaryKey) !== null && _a !== void 0 ? _a : '_id';\n    }\n    /**\n     * 获取集合的引用\n     *\n     * @param collName - 集合名称\n     */\n    collection(collName) {\n        if (!collName) {\n            throw new Error('Collection name is required');\n        }\n        return new collection_1.CollectionReference(this, collName);\n    }\n    /**\n     * Generate a hex string id for document\n     * @returns\n     */\n    generateId() {\n        const id = new bson_1.ObjectId();\n        return id.toHexString();\n    }\n    /**\n     * Wrapper for ObjectId() of mongodb\n     * @param params\n     * @returns\n     */\n    ObjectId(id) {\n        return new bson_1.ObjectId(id);\n    }\n}\nexports.Db = Db;\n","\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./point\"));\n__export(require(\"./lineString\"));\n__export(require(\"./polygon\"));\n__export(require(\"./multiPoint\"));\n__export(require(\"./multiLineString\"));\n__export(require(\"./multiPolygon\"));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"../validate\");\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\n/**\n * 地址位置\n *\n * @author haroldhu\n */\nclass Point {\n    /**\n     * 初始化\n     *\n     * @param latitude    - 纬度 [-90, 90]\n     * @param longitude   - 经度 [-180, 180]\n     */\n    constructor(longitude, latitude) {\n        validate_1.Validate.isGeopoint('longitude', longitude);\n        validate_1.Validate.isGeopoint('latitude', latitude);\n        this.longitude = longitude;\n        this.latitude = latitude;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'Point',\n                coordinates: [this.longitude, this.latitude]\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'Point',\n            coordinates: [\n                this.longitude,\n                this.latitude,\n            ],\n        };\n    }\n    toReadableString() {\n        return `[${this.longitude},${this.latitude}]`;\n    }\n    static validate(point) {\n        return point.type === 'Point' &&\n            type_1.isArray(point.coordinates) &&\n            validate_1.Validate.isGeopoint('longitude', point.coordinates[0]) &&\n            validate_1.Validate.isGeopoint('latitude', point.coordinates[1]);\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_POINT;\n    }\n}\nexports.Point = Point;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_1 = require(\"./constant\");\nconst util_1 = require(\"./util\");\nconst type_1 = require(\"./utils/type\");\n/**\n * 校验模块\n *\n * @author haroldhu\n * @internal\n */\nclass Validate {\n    /**\n    *\n    * @static\n    * @param {StageName:{}|string} stage\n    * @returns {Boolean}\n    * @memberof Validate\n    */\n    static isValidAggregation(stage) {\n        if (Object.keys(stage).length !== 1) {\n            throw new Error('aggregation stage must have one key');\n        }\n        return true;\n    }\n    /**\n     * 检测地址位置的点\n     *\n     * @param point   - 经纬度\n     * @param degree  - 数值\n     */\n    static isGeopoint(point, degree) {\n        if (util_1.Util.whichType(degree) !== constant_1.FieldType.Number) {\n            throw new Error('Geo Point must be number type');\n        }\n        // 位置的绝对值\n        const degreeAbs = Math.abs(degree);\n        if (point === 'latitude' && degreeAbs > 90) {\n            throw new Error('latitude should be a number ranges from -90 to 90');\n        }\n        else if (point === 'longitude' && degreeAbs > 180) {\n            throw new Error('longitude should be a number ranges from -180 to 180');\n        }\n        return true;\n    }\n    /**\n     * 参数是否为整数\n     *\n     * @param param - 要验证的参数名\n     * @param num   - 要验证的参数值\n     */\n    static isInteger(param, num) {\n        if (!Number.isInteger(num)) {\n            throw new Error(param + constant_1.ErrorCode.IntegerError);\n        }\n        return true;\n    }\n    static isProjection(param, value) {\n        // 遍历value 的 属性值， 只有1，0，ProjectionOperator 三种类型\n        if (type_1.getType(value) !== 'object') {\n            throw new Error(`${param} projection must be an object`);\n        }\n        for (const key in value) {\n            const subValue = value[key];\n            if (type_1.getType(subValue) === 'number') {\n                if (subValue !== 0 && subValue !== 1) {\n                    throw new Error('if the value in projection is of number, it must be 0 or 1');\n                }\n            }\n            else if (type_1.getType(subValue) === 'object') {\n            }\n            else {\n                throw new Error('invalid projection');\n            }\n        }\n        return true;\n    }\n    static isOrder(param, value) {\n        if (type_1.getType(value) !== 'object') {\n            throw new Error(`${param} order must be an object`);\n        }\n        for (let key in value) {\n            const subValue = value[key];\n            if (subValue !== 1 && subValue !== -1) {\n                throw new Error(`order value must be 1 or -1`);\n            }\n        }\n        return true;\n    }\n    /**\n     * 是否为合法的排序字符\n     *\n     * @param direction\n     */\n    static isFieldOrder(direction) {\n        if (constant_1.OrderDirectionList.indexOf(direction) === -1) {\n            throw new Error(constant_1.ErrorCode.DirectionError);\n        }\n        return true;\n    }\n    /**\n     * 是否为合法的字段地址\n     *\n     * 只能是连续字段名+英文点号\n     *\n     * @param path\n     */\n    static isFieldPath(path) {\n        if (!/^[a-zA-Z0-9-_\\.]/.test(path)) {\n            throw new Error();\n        }\n        return true;\n    }\n    /**\n     * 是否为合法操作符\n     *\n     * @param op\n     */\n    static isOperator(op) {\n        if (constant_1.WhereFilterOpList.indexOf(op) === -1) {\n            throw new Error(constant_1.ErrorCode.OpStrError);\n        }\n        return true;\n    }\n    /**\n     * 集合名称是否正确\n     *\n     * 只能以数字字母开头\n     * 可以包含字母数字、减号、下划线\n     * 最大长度32位\n     *\n     * @param name\n     */\n    static isCollName(name) {\n        if (!/^[a-zA-Z0-9]([a-zA-Z0-9-_]){1,32}$/.test(name)) {\n            throw new Error(constant_1.ErrorCode.CollNameError);\n        }\n        return true;\n    }\n}\nexports.Validate = Validate;\n","\n/**\n * 常量模块\n *\n * @author haroldhu\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 错误码\n */\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"DocIDError\"] = \"\\u6587\\u6863ID\\u4E0D\\u5408\\u6CD5\";\n    ErrorCode[\"CollNameError\"] = \"\\u96C6\\u5408\\u540D\\u79F0\\u4E0D\\u5408\\u6CD5\";\n    ErrorCode[\"OpStrError\"] = \"\\u64CD\\u4F5C\\u7B26\\u4E0D\\u5408\\u6CD5\";\n    ErrorCode[\"DirectionError\"] = \"\\u6392\\u5E8F\\u5B57\\u7B26\\u4E0D\\u5408\\u6CD5\";\n    ErrorCode[\"IntegerError\"] = \"must be integer\";\n    ErrorCode[\"QueryParamTypeError\"] = \"\\u67E5\\u8BE2\\u53C2\\u6570\\u5FC5\\u987B\\u4E3A\\u5BF9\\u8C61\";\n    ErrorCode[\"QueryParamValueError\"] = \"\\u67E5\\u8BE2\\u53C2\\u6570\\u5BF9\\u8C61\\u503C\\u4E0D\\u80FD\\u5747\\u4E3Aundefined\";\n})(ErrorCode || (ErrorCode = {}));\nexports.ErrorCode = ErrorCode;\n/**\n * 字段类型\n */\nconst FieldType = {\n    String: 'String',\n    Number: 'Number',\n    Object: 'Object',\n    Array: 'Array',\n    Boolean: 'Boolean',\n    Null: 'Null',\n    GeoPoint: 'GeoPoint',\n    GeoLineString: 'GeoLineString',\n    GeoPolygon: 'GeoPolygon',\n    GeoMultiPoint: 'GeoMultiPoint',\n    GeoMultiLineString: 'GeoMultiLineString',\n    GeoMultiPolygon: 'GeoMultiPolygon',\n    Timestamp: 'Date',\n    Command: 'Command',\n    ServerDate: 'ServerDate',\n    BsonDate: 'BsonDate',\n    ObjectId: 'ObjectId',\n    Binary: 'Binary'\n};\nexports.FieldType = FieldType;\n/**\n * 排序方向列表\n */\nconst OrderDirectionList = ['desc', 'asc'];\nexports.OrderDirectionList = OrderDirectionList;\n/**\n * 操作符列表\n */\nconst WhereFilterOpList = ['<', '<=', '==', '>=', '>'];\nexports.WhereFilterOpList = WhereFilterOpList;\n/**\n * 操作符别名\n */\nvar Operator;\n(function (Operator) {\n    Operator[\"lt\"] = \"<\";\n    Operator[\"gt\"] = \">\";\n    Operator[\"lte\"] = \"<=\";\n    Operator[\"gte\"] = \">=\";\n    Operator[\"eq\"] = \"==\";\n})(Operator || (Operator = {}));\nexports.Operator = Operator;\n/**\n * 操作符映射\n * SDK => MongoDB\n */\nconst OperatorMap = {\n    [Operator.eq]: '$eq',\n    [Operator.lt]: '$lt',\n    [Operator.lte]: '$lte',\n    [Operator.gt]: '$gt',\n    [Operator.gte]: '$gte'\n};\nexports.OperatorMap = OperatorMap;\nconst UpdateOperatorList = [\n    '$set',\n    '$inc',\n    '$mul',\n    '$unset',\n    '$push',\n    '$pop',\n    '$unshift',\n    '$shift',\n    '$currentDate',\n    '$each',\n    '$position'\n];\nexports.UpdateOperatorList = UpdateOperatorList;\nvar ActionType;\n(function (ActionType) {\n    ActionType[\"add\"] = \"database.addDocument\";\n    ActionType[\"query\"] = \"database.queryDocument\";\n    ActionType[\"update\"] = \"database.updateDocument\";\n    ActionType[\"count\"] = \"database.countDocument\";\n    ActionType[\"remove\"] = \"database.deleteDocument\";\n    ActionType[\"aggregate\"] = \"database.aggregateDocuments\";\n})(ActionType || (ActionType = {}));\nexports.ActionType = ActionType;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bson_1 = require(\"bson\");\nconst constant_1 = require(\"./constant\");\nconst index_1 = require(\"./geo/index\");\nconst index_2 = require(\"./serverDate/index\");\n/**\n * 工具模块\n *\n */\nclass Util {\n}\nexports.Util = Util;\n/**\n * 格式化后端返回的文档数据\n *\n * @param document - 后端文档数据\n */\nUtil.formatResDocumentData = (documents) => {\n    return documents.map(document => {\n        return Util.formatField(document);\n    });\n};\n/**\n * 格式化字段\n *\n * 主要是递归数组和对象，把地理位置和日期时间转换为js对象。\n *\n * @param document\n * @internal\n */\nUtil.formatField = document => {\n    const keys = Object.keys(document);\n    let protoField = {};\n    // 数组递归的情况\n    if (Array.isArray(document)) {\n        protoField = [];\n    }\n    keys.forEach(key => {\n        const item = document[key];\n        const type = Util.whichType(item);\n        let realValue;\n        switch (type) {\n            case constant_1.FieldType.GeoPoint:\n                realValue = new index_1.Point(item.coordinates[0], item.coordinates[1]);\n                break;\n            case constant_1.FieldType.GeoLineString:\n                realValue = new index_1.LineString(item.coordinates.map(point => new index_1.Point(point[0], point[1])));\n                break;\n            case constant_1.FieldType.GeoPolygon:\n                realValue = new index_1.Polygon(item.coordinates.map(line => new index_1.LineString(line.map(([lng, lat]) => new index_1.Point(lng, lat)))));\n                break;\n            case constant_1.FieldType.GeoMultiPoint:\n                realValue = new index_1.MultiPoint(item.coordinates.map(point => new index_1.Point(point[0], point[1])));\n                break;\n            case constant_1.FieldType.GeoMultiLineString:\n                realValue = new index_1.MultiLineString(item.coordinates.map(line => new index_1.LineString(line.map(([lng, lat]) => new index_1.Point(lng, lat)))));\n                break;\n            case constant_1.FieldType.GeoMultiPolygon:\n                realValue = new index_1.MultiPolygon(item.coordinates.map(polygon => new index_1.Polygon(polygon.map(line => new index_1.LineString(line.map(([lng, lat]) => new index_1.Point(lng, lat)))))));\n                break;\n            case constant_1.FieldType.Timestamp:\n                realValue = new Date(item.$timestamp * 1000);\n                break;\n            case constant_1.FieldType.Object:\n            case constant_1.FieldType.Array:\n                realValue = Util.formatField(item);\n                break;\n            case constant_1.FieldType.ServerDate:\n                realValue = new Date(item.$date);\n                break;\n            case constant_1.FieldType.ObjectId:\n                realValue = bson_1.EJSON.deserialize(item);\n                break;\n            case constant_1.FieldType.Binary:\n                realValue = bson_1.EJSON.deserialize(item);\n                break;\n            default:\n                realValue = item;\n        }\n        if (Array.isArray(protoField)) {\n            protoField.push(realValue);\n        }\n        else {\n            protoField[key] = realValue;\n        }\n    });\n    return protoField;\n};\n/**\n * 查看数据类型\n *\n * @param obj\n */\nUtil.whichType = (obj) => {\n    let type = Object.prototype.toString.call(obj).slice(8, -1);\n    if (type === constant_1.FieldType.Timestamp) {\n        return constant_1.FieldType.BsonDate;\n    }\n    if (type === constant_1.FieldType.Object) {\n        if (obj instanceof index_1.Point) {\n            return constant_1.FieldType.GeoPoint;\n        }\n        else if (obj instanceof Date) {\n            return constant_1.FieldType.Timestamp;\n        } /* else if (obj instanceof Command) {\n          return FieldType.Command;\n        } */\n        else if (obj instanceof index_2.ServerDate) {\n            return constant_1.FieldType.ServerDate;\n        }\n        else if (obj instanceof bson_1.ObjectId) {\n            return constant_1.FieldType.ObjectId;\n        }\n        else if (obj instanceof bson_1.Binary) {\n            return constant_1.FieldType.Binary;\n        }\n        if (obj.$timestamp) {\n            type = constant_1.FieldType.Timestamp;\n        }\n        else if (obj.$date) {\n            type = constant_1.FieldType.ServerDate;\n        }\n        else if (index_1.Point.validate(obj)) {\n            type = constant_1.FieldType.GeoPoint;\n        }\n        else if (index_1.LineString.validate(obj)) {\n            type = constant_1.FieldType.GeoLineString;\n        }\n        else if (index_1.Polygon.validate(obj)) {\n            type = constant_1.FieldType.GeoPolygon;\n        }\n        else if (index_1.MultiPoint.validate(obj)) {\n            type = constant_1.FieldType.GeoMultiPoint;\n        }\n        else if (index_1.MultiLineString.validate(obj)) {\n            type = constant_1.FieldType.GeoMultiLineString;\n        }\n        else if (index_1.MultiPolygon.validate(obj)) {\n            type = constant_1.FieldType.GeoMultiPolygon;\n        }\n        else if (obj.$oid) {\n            type = constant_1.FieldType.ObjectId;\n        }\n        else if (obj.$binary) {\n            type = constant_1.FieldType.Binary;\n        }\n    }\n    return type;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nclass ServerDate {\n    constructor({ offset = 0 } = {}) {\n        this.offset = offset;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_SERVER_DATE;\n    }\n    parse() {\n        return {\n            $date: {\n                offset: this.offset\n            }\n        };\n    }\n}\nexports.ServerDate = ServerDate;\n/**\n * @deprecated This method is deprecated, not implemented in server side\n * @param opt\n * @returns\n */\nfunction ServerDateConstructor(opt) {\n    return new ServerDate(opt);\n}\nexports.ServerDateConstructor = ServerDateConstructor;\n","\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../utils/symbol\");\n__export(require(\"../utils/symbol\"));\nexports.SYMBOL_UNSET_FIELD_NAME = symbol_1.default.for('UNSET_FIELD_NAME');\nexports.SYMBOL_UPDATE_COMMAND = symbol_1.default.for('UPDATE_COMMAND');\nexports.SYMBOL_QUERY_COMMAND = symbol_1.default.for('QUERY_COMMAND');\nexports.SYMBOL_LOGIC_COMMAND = symbol_1.default.for('LOGIC_COMMAND');\nexports.SYMBOL_GEO_POINT = symbol_1.default.for('GEO_POINT');\nexports.SYMBOL_GEO_LINE_STRING = symbol_1.default.for('SYMBOL_GEO_LINE_STRING');\nexports.SYMBOL_GEO_POLYGON = symbol_1.default.for('SYMBOL_GEO_POLYGON');\nexports.SYMBOL_GEO_MULTI_POINT = symbol_1.default.for('SYMBOL_GEO_MULTI_POINT');\nexports.SYMBOL_GEO_MULTI_LINE_STRING = symbol_1.default.for('SYMBOL_GEO_MULTI_LINE_STRING');\nexports.SYMBOL_GEO_MULTI_POLYGON = symbol_1.default.for('SYMBOL_GEO_MULTI_POLYGON');\nexports.SYMBOL_SERVER_DATE = symbol_1.default.for('SERVER_DATE');\nexports.SYMBOL_REGEXP = symbol_1.default.for('REGEXP');\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _symbols = [];\nconst __internalMark__ = {};\nclass HiddenSymbol {\n    constructor(target) {\n        Object.defineProperties(this, {\n            target: {\n                enumerable: false,\n                writable: false,\n                configurable: false,\n                value: target,\n            },\n        });\n    }\n}\nclass InternalSymbol extends HiddenSymbol {\n    constructor(target, __mark__) {\n        if (__mark__ !== __internalMark__) {\n            throw new TypeError('InternalSymbol cannot be constructed with new operator');\n        }\n        super(target);\n    }\n    static for(target) {\n        for (let i = 0, len = _symbols.length; i < len; i++) {\n            if (_symbols[i].target === target) {\n                return _symbols[i].instance;\n            }\n        }\n        const symbol = new InternalSymbol(target, __internalMark__);\n        _symbols.push({\n            target,\n            instance: symbol,\n        });\n        return symbol;\n    }\n}\nexports.InternalSymbol = InternalSymbol;\nexports.default = InternalSymbol;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"./symbol\");\nexports.getType = (x) => Object.prototype.toString.call(x).slice(8, -1).toLowerCase();\nexports.isObject = (x) => exports.getType(x) === 'object';\nexports.isString = (x) => exports.getType(x) === 'string';\nexports.isNumber = (x) => exports.getType(x) === 'number';\nexports.isPromise = (x) => exports.getType(x) === 'promise';\nexports.isFunction = (x) => typeof x === 'function';\nexports.isArray = (x) => Array.isArray(x);\nexports.isDate = (x) => exports.getType(x) === 'date';\nexports.isRegExp = (x) => exports.getType(x) === 'regexp';\n/**\n * Internal Object can be:  `LogicCommand` | `QueryCommand` | `UpdateCommand`\n * @param x\n * @returns\n */\nexports.isInternalObject = (x) => x && (x._internalType instanceof symbol_1.InternalSymbol);\nexports.isPlainObject = (obj) => {\n    if (typeof obj !== 'object' || obj === null)\n        return false;\n    let proto = obj;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto;\n};\nexports.isObjectId = (x) => {\n    return (x === null || x === void 0 ? void 0 : x._bsontype) === 'ObjectID';\n};\nexports.isBinary = (x) => {\n    return (x === null || x === void 0 ? void 0 : x._bsontype) === 'Binary';\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst point_1 = require(\"./point\");\nconst type_1 = require(\"../utils/type\");\n/**\n * 线段\n *\n * @author starkewang\n */\nclass LineString {\n    /**\n     * 初始化\n     *\n     * @param points    - GeoPoint\n     */\n    constructor(points) {\n        if (!type_1.isArray(points)) {\n            throw new TypeError(`\"points\" must be of type Point[]. Received type ${typeof points}`);\n        }\n        if (points.length < 2) {\n            throw new Error('\"points\" must contain 2 points at least');\n        }\n        points.forEach(point => {\n            if (!(point instanceof point_1.Point)) {\n                throw new TypeError(`\"points\" must be of type Point[]. Received type ${typeof point}[]`);\n            }\n        });\n        this.points = points;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'LineString',\n                coordinates: this.points.map(point => point.toJSON().coordinates)\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'LineString',\n            coordinates: this.points.map(point => point.toJSON().coordinates)\n        };\n    }\n    static validate(lineString) {\n        if (lineString.type !== 'LineString' || !type_1.isArray(lineString.coordinates)) {\n            return false;\n        }\n        for (let point of lineString.coordinates) {\n            if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static isClosed(lineString) {\n        const firstPoint = lineString.points[0];\n        const lastPoint = lineString.points[lineString.points.length - 1];\n        if (firstPoint.latitude === lastPoint.latitude && firstPoint.longitude === lastPoint.longitude) {\n            return true;\n        }\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_LINE_STRING;\n    }\n}\nexports.LineString = LineString;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst lineString_1 = require(\"./lineString\");\n/**\n * 面\n *\n * @author starkewang\n */\nclass Polygon {\n    /**\n     * 初始化\n     *\n     * @param lines    - LineString\n     */\n    constructor(lines) {\n        if (!type_1.isArray(lines)) {\n            throw new TypeError(`\"lines\" must be of type LineString[]. Received type ${typeof lines}`);\n        }\n        if (lines.length === 0) {\n            throw new Error('Polygon must contain 1 linestring at least');\n        }\n        lines.forEach(line => {\n            if (!(line instanceof lineString_1.LineString)) {\n                throw new TypeError(`\"lines\" must be of type LineString[]. Received type ${typeof line}[]`);\n            }\n            if (!lineString_1.LineString.isClosed(line)) {\n                throw new Error(`LineString ${line.points.map(p => p.toReadableString())} is not a closed cycle`);\n            }\n        });\n        this.lines = lines;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'Polygon',\n                coordinates: this.lines.map(line => {\n                    return line.points.map(point => [point.longitude, point.latitude]);\n                })\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'Polygon',\n            coordinates: this.lines.map(line => {\n                return line.points.map(point => [point.longitude, point.latitude]);\n            })\n        };\n    }\n    static validate(polygon) {\n        if (polygon.type !== 'Polygon' || !type_1.isArray(polygon.coordinates)) {\n            return false;\n        }\n        for (let line of polygon.coordinates) {\n            if (!this.isCloseLineString(line)) {\n                return false;\n            }\n            for (let point of line) {\n                if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static isCloseLineString(lineString) {\n        const firstPoint = lineString[0];\n        const lastPoint = lineString[lineString.length - 1];\n        if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {\n            return false;\n        }\n        return true;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_MULTI_POLYGON;\n    }\n}\nexports.Polygon = Polygon;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst point_1 = require(\"./point\");\nconst type_1 = require(\"../utils/type\");\n/**\n * 多个 Point\n *\n * @author starkewang\n */\nclass MultiPoint {\n    /**\n     * 初始化\n     *\n     * @param points    - GeoPoint\n     */\n    constructor(points) {\n        if (!type_1.isArray(points)) {\n            throw new TypeError(`\"points\" must be of type Point[]. Received type ${typeof points}`);\n        }\n        if (points.length === 0) {\n            throw new Error('\"points\" must contain 1 point at least');\n        }\n        points.forEach(point => {\n            if (!(point instanceof point_1.Point)) {\n                throw new TypeError(`\"points\" must be of type Point[]. Received type ${typeof point}[]`);\n            }\n        });\n        this.points = points;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'MultiPoint',\n                coordinates: this.points.map(point => point.toJSON().coordinates)\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'MultiPoint',\n            coordinates: this.points.map(point => point.toJSON().coordinates)\n        };\n    }\n    static validate(multiPoint) {\n        if (multiPoint.type !== 'MultiPoint' || !type_1.isArray(multiPoint.coordinates)) {\n            return false;\n        }\n        for (let point of multiPoint.coordinates) {\n            if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_MULTI_POINT;\n    }\n}\nexports.MultiPoint = MultiPoint;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst lineString_1 = require(\"./lineString\");\n/**\n * 多个 LineString\n *\n * @author starkewang\n */\nclass MultiLineString {\n    /**\n     * 初始化\n     *\n     * @param lines    - LineString\n     */\n    constructor(lines) {\n        if (!type_1.isArray(lines)) {\n            throw new TypeError(`\"lines\" must be of type LineString[]. Received type ${typeof lines}`);\n        }\n        if (lines.length === 0) {\n            throw new Error('Polygon must contain 1 linestring at least');\n        }\n        lines.forEach(line => {\n            if (!(line instanceof lineString_1.LineString)) {\n                throw new TypeError(`\"lines\" must be of type LineString[]. Received type ${typeof line}[]`);\n            }\n        });\n        this.lines = lines;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'MultiLineString',\n                coordinates: this.lines.map(line => {\n                    return line.points.map(point => [point.longitude, point.latitude]);\n                })\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'MultiLineString',\n            coordinates: this.lines.map(line => {\n                return line.points.map(point => [point.longitude, point.latitude]);\n            })\n        };\n    }\n    static validate(multiLineString) {\n        if (multiLineString.type !== 'MultiLineString' || !type_1.isArray(multiLineString.coordinates)) {\n            return false;\n        }\n        for (let line of multiLineString.coordinates) {\n            for (let point of line) {\n                if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_MULTI_LINE_STRING;\n    }\n}\nexports.MultiLineString = MultiLineString;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst polygon_1 = require(\"./polygon\");\n/**\n * 多个面\n *\n * @author starkewang\n */\nclass MultiPolygon {\n    /**\n     * 初始化\n     *\n     * @param polygons    - Polygon[]\n     */\n    constructor(polygons) {\n        if (!type_1.isArray(polygons)) {\n            throw new TypeError(`\"polygons\" must be of type Polygon[]. Received type ${typeof polygons}`);\n        }\n        if (polygons.length === 0) {\n            throw new Error('MultiPolygon must contain 1 polygon at least');\n        }\n        for (let polygon of polygons) {\n            if (!(polygon instanceof polygon_1.Polygon)) {\n                throw new TypeError(`\"polygon\" must be of type Polygon[]. Received type ${typeof polygon}[]`);\n            }\n        }\n        this.polygons = polygons;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'MultiPolygon',\n                coordinates: this.polygons.map(polygon => {\n                    return polygon.lines.map(line => {\n                        return line.points.map(point => [point.longitude, point.latitude]);\n                    });\n                })\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'MultiPolygon',\n            coordinates: this.polygons.map(polygon => {\n                return polygon.lines.map(line => {\n                    return line.points.map(point => [point.longitude, point.latitude]);\n                });\n            })\n        };\n    }\n    static validate(multiPolygon) {\n        if (multiPolygon.type !== 'MultiPolygon' || !type_1.isArray(multiPolygon.coordinates)) {\n            return false;\n        }\n        for (let polygon of multiPolygon.coordinates) {\n            for (let line of polygon) {\n                for (let point of line) {\n                    if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_POLYGON;\n    }\n}\nexports.MultiPolygon = MultiPolygon;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst document_1 = require(\"./document\");\nconst query_1 = require(\"./query\");\nconst aggregate_1 = require(\"./aggregate\");\n/**\n * 集合模块，继承 Query 模块\n *\n */\nclass CollectionReference extends query_1.Query {\n    /**\n     * 初始化\n     *\n     * @internal\n     *\n     * @param db    - 数据库的引用\n     * @param coll  - 集合名称\n     */\n    constructor(db, coll) {\n        super(db, coll);\n    }\n    /**\n     * 读取集合名字\n     */\n    get name() {\n        return this._coll;\n    }\n    /**\n     * 获取文档的引用\n     *\n     * @param docID - 文档 ID\n     */\n    doc(docID) {\n        if (!docID) {\n            throw new Error('docID cannot be empty');\n        }\n        return new document_1.DocumentReference(this._db, this._coll, docID);\n    }\n    /**\n     * 添加一篇文档\n     *\n     * @param data - 数据\n     */\n    add(data, options) {\n        let docRef = new document_1.DocumentReference(this._db, this._coll, undefined);\n        return docRef.create(data, options);\n    }\n    aggregate(rawPipeline = []) {\n        return new aggregate_1.default(this._db, this._coll, rawPipeline);\n    }\n}\nexports.CollectionReference = CollectionReference;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst datatype_1 = require(\"./serializer/datatype\");\nconst update_1 = require(\"./commands/update\");\nconst constant_1 = require(\"./constant\");\nconst query_1 = require(\"./query\");\n/**\n * Db document\n */\nclass DocumentReference {\n    /**\n     * @param db    - db ref\n     * @param coll  - collection\n     * @param docID - document id\n     */\n    constructor(db, coll, docID, query) {\n        this._db = db;\n        this._coll = coll;\n        this.id = docID;\n        this._query = query || new query_1.Query(db, coll);\n    }\n    /**\n     * 创建一篇文档\n     *\n     * @param data - document data\n     */\n    async create(data, options) {\n        var _a, _b;\n        if (!data || typeof data !== 'object' || 0 === ((_a = Object.keys(data)) === null || _a === void 0 ? void 0 : _a.length)) {\n            throw new Error('data cannot be empty object');\n        }\n        const params = {\n            collectionName: this._coll,\n            data: datatype_1.serialize(data),\n            multi: (_b = options === null || options === void 0 ? void 0 : options.multi) !== null && _b !== void 0 ? _b : false\n        };\n        const res = await this._query\n            .send(constant_1.ActionType.add, params);\n        if (res.error) {\n            return {\n                requestId: res.requestId,\n                error: res.error,\n                ok: false,\n                id: undefined,\n                insertedCount: undefined,\n                code: res.code\n            };\n        }\n        return {\n            id: res.data._id || res.data[this._db.primaryKey],\n            insertedCount: res.data.insertedCount,\n            requestId: res.requestId,\n            ok: true\n        };\n    }\n    /**\n     * 创建或添加数据\n     *\n     * 如果该文档 ID 在数据库中不存在，则创建该文档并插入数据，根据返回数据的 upsertId 判断\n     *\n     * @param data - document data\n     */\n    async set(data) {\n        if (!this.id) {\n            throw new Error('document id cannot be empty');\n        }\n        let hasOperator = false;\n        const checkMixed = (objs) => {\n            if (typeof objs === 'object') {\n                for (let key in objs) {\n                    if (objs[key] instanceof update_1.UpdateCommand) {\n                        hasOperator = true;\n                    }\n                    else if (typeof objs[key] === 'object') {\n                        checkMixed(objs[key]);\n                    }\n                }\n            }\n        };\n        checkMixed(data);\n        if (hasOperator) {\n            // 不能包含操作符\n            throw new Error('data cannot contain operator');\n        }\n        // merge === false indicates replace operation\n        const merge = false;\n        const res = await this._query\n            .where({ [this._db.primaryKey]: this.id })\n            .update(datatype_1.serialize(data), { merge, multi: false, upsert: true });\n        return res;\n    }\n    /**\n     * 更新数据\n     *\n     * @param data - 文档数据\n     */\n    async update(data) {\n        // 把所有更新数据转为带操作符的\n        const merge = true;\n        const options = { merge, multi: false, upsert: false };\n        const res = await this._query\n            .where({ [this._db.primaryKey]: this.id })\n            .update(data, options);\n        return res;\n    }\n    /**\n     * 删除文档\n     */\n    async remove() {\n        const res = await this._query\n            .where({ [this._db.primaryKey]: this.id })\n            .remove({ multi: false });\n        return res;\n    }\n    /**\n     * 返回选中的文档\n     */\n    async get() {\n        const res = await this._query\n            .where({ [this._db.primaryKey]: this.id })\n            .getOne();\n        return res;\n    }\n    /**\n     * 指定要返回的字段\n     *\n     * @param projection\n     */\n    field(projection) {\n        return new DocumentReference(this._db, this._coll, this.id, this._query.field(projection));\n    }\n}\nexports.DocumentReference = DocumentReference;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// transpile internal data type\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst index_1 = require(\"../geo/index\");\nconst index_2 = require(\"../serverDate/index\");\nconst bson_1 = require(\"bson\");\nfunction serialize(val) {\n    return serializeHelper(val, [val]);\n}\nexports.serialize = serialize;\nfunction serializeHelper(val, visited) {\n    if (type_1.isInternalObject(val)) {\n        switch (val._internalType) {\n            case symbol_1.SYMBOL_GEO_POINT: {\n                return val.toJSON();\n            }\n            case symbol_1.SYMBOL_SERVER_DATE: {\n                return val.parse();\n            }\n            case symbol_1.SYMBOL_REGEXP: {\n                return val.parse();\n            }\n            default: {\n                return val.toJSON ? val.toJSON() : val;\n            }\n        }\n    }\n    else if (type_1.isDate(val) || type_1.isRegExp(val) || type_1.isObjectId(val) || type_1.isBinary(val)) {\n        return bson_1.EJSON.serialize(val);\n    }\n    else if (type_1.isArray(val)) {\n        return val.map(item => {\n            if (visited.indexOf(item) > -1) {\n                throw new Error('Cannot convert circular structure to JSON');\n            }\n            return serializeHelper(item, [\n                ...visited,\n                item,\n            ]);\n        });\n    }\n    else if (type_1.isObject(val)) {\n        const ret = Object.assign({}, val);\n        for (const key in ret) {\n            if (visited.indexOf(ret[key]) > -1) {\n                throw new Error('Cannot convert circular structure to JSON');\n            }\n            ret[key] = serializeHelper(ret[key], [\n                ...visited,\n                ret[key],\n            ]);\n        }\n        return ret;\n    }\n    else {\n        return val;\n    }\n}\nfunction deserialize(object) {\n    const ret = Object.assign({}, object);\n    for (const key in ret) {\n        switch (key) {\n            case '$date': {\n                switch (type_1.getType(ret[key])) {\n                    case 'number': {\n                        // normal timestamp\n                        return new Date(ret[key]);\n                    }\n                    case 'object': {\n                        // serverDate\n                        return new index_2.ServerDate(ret[key]);\n                    }\n                }\n                break;\n            }\n            case 'type': {\n                switch (ret.type) {\n                    case 'Point': {\n                        // GeoPoint\n                        if (type_1.isArray(ret.coordinates) && type_1.isNumber(ret.coordinates[0]) && type_1.isNumber(ret.coordinates[1])) {\n                            return new index_1.Point(ret.coordinates[0], ret.coordinates[1]);\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    return object;\n}\nexports.deserialize = deserialize;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nvar UPDATE_COMMANDS_LITERAL;\n(function (UPDATE_COMMANDS_LITERAL) {\n    UPDATE_COMMANDS_LITERAL[\"SET\"] = \"set\";\n    UPDATE_COMMANDS_LITERAL[\"REMOVE\"] = \"remove\";\n    UPDATE_COMMANDS_LITERAL[\"INC\"] = \"inc\";\n    UPDATE_COMMANDS_LITERAL[\"MUL\"] = \"mul\";\n    UPDATE_COMMANDS_LITERAL[\"PUSH\"] = \"push\";\n    UPDATE_COMMANDS_LITERAL[\"PULL\"] = \"pull\";\n    UPDATE_COMMANDS_LITERAL[\"PULL_ALL\"] = \"pullAll\";\n    UPDATE_COMMANDS_LITERAL[\"POP\"] = \"pop\";\n    UPDATE_COMMANDS_LITERAL[\"SHIFT\"] = \"shift\";\n    UPDATE_COMMANDS_LITERAL[\"UNSHIFT\"] = \"unshift\";\n    UPDATE_COMMANDS_LITERAL[\"ADD_TO_SET\"] = \"addToSet\";\n    UPDATE_COMMANDS_LITERAL[\"BIT\"] = \"bit\";\n    UPDATE_COMMANDS_LITERAL[\"RENAME\"] = \"rename\";\n    UPDATE_COMMANDS_LITERAL[\"MAX\"] = \"max\";\n    UPDATE_COMMANDS_LITERAL[\"MIN\"] = \"min\";\n})(UPDATE_COMMANDS_LITERAL = exports.UPDATE_COMMANDS_LITERAL || (exports.UPDATE_COMMANDS_LITERAL = {}));\nclass UpdateCommand {\n    constructor(operator, operands, fieldName) {\n        this._internalType = symbol_1.SYMBOL_UPDATE_COMMAND;\n        Object.defineProperties(this, {\n            _internalType: {\n                enumerable: false,\n                configurable: false,\n            },\n        });\n        this.operator = operator;\n        this.operands = operands;\n        this.fieldName = fieldName || symbol_1.SYMBOL_UNSET_FIELD_NAME;\n    }\n    _setFieldName(fieldName) {\n        const command = new UpdateCommand(this.operator, this.operands, fieldName);\n        return command;\n    }\n}\nexports.UpdateCommand = UpdateCommand;\nfunction isUpdateCommand(object) {\n    return object && (object instanceof UpdateCommand) && (object._internalType === symbol_1.SYMBOL_UPDATE_COMMAND);\n}\nexports.isUpdateCommand = isUpdateCommand;\nfunction isKnownUpdateCommand(object) {\n    return isUpdateCommand(object) && (object.operator.toUpperCase() in UPDATE_COMMANDS_LITERAL);\n}\nexports.isKnownUpdateCommand = isKnownUpdateCommand;\nexports.default = UpdateCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_1 = require(\"./constant\");\nconst validate_1 = require(\"./validate\");\n// import { Util } from './util'\nconst query_1 = require(\"./serializer/query\");\nconst update_1 = require(\"./serializer/update\");\nconst constant_2 = require(\"./constant\");\nconst util_1 = require(\"./util\");\nconst datatype_1 = require(\"./serializer/datatype\");\n/**\n * Db query\n */\nclass Query {\n    /**\n     * @param db            - db reference\n     * @param coll          - collection name\n     * @param fieldFilters  - query condition\n     * @param fieldOrders   - order by condition\n     * @param queryOptions  - query options\n     */\n    constructor(db, coll, fieldFilters, fieldOrders, queryOptions, withs) {\n        this._db = db;\n        this._coll = coll;\n        this._fieldFilters = fieldFilters;\n        this._fieldOrders = fieldOrders || [];\n        this._queryOptions = queryOptions || {};\n        this._withs = withs || [];\n        this._request = this._db.request;\n    }\n    /**\n     * 查询条件\n     *\n     * @param query\n     */\n    where(query) {\n        // query校验 1. 必填对象类型  2. value 不可均为 undefiend\n        if (Object.prototype.toString.call(query).slice(8, -1) !== 'Object') {\n            throw Error(constant_2.ErrorCode.QueryParamTypeError);\n        }\n        const keys = Object.keys(query);\n        const checkFlag = keys.some(item => {\n            return query[item] !== undefined;\n        });\n        if (keys.length && !checkFlag) {\n            throw Error(constant_2.ErrorCode.QueryParamValueError);\n        }\n        const _query = query_1.QuerySerializer.encode(query);\n        return new Query(this._db, this._coll, _query, this._fieldOrders, this._queryOptions, this._withs);\n    }\n    /**\n     * 设置排序方式\n     *\n     * @param fieldPath     - 字段路径\n     * @param directionStr  - 排序方式\n     */\n    orderBy(fieldPath, directionStr) {\n        validate_1.Validate.isFieldPath(fieldPath);\n        validate_1.Validate.isFieldOrder(directionStr);\n        const newOrder = {\n            field: fieldPath,\n            direction: directionStr\n        };\n        const combinedOrders = this._fieldOrders.concat(newOrder);\n        return new Query(this._db, this._coll, this._fieldFilters, combinedOrders, this._queryOptions, this._withs);\n    }\n    /**\n     * 添加 一对多 子查询条件\n     * @param param {WithParam}\n     * @returns Query\n     */\n    with(param) {\n        var _a, _b;\n        const newWith = {\n            query: param.query,\n            foreignField: param.foreignField,\n            localField: param.localField,\n            as: (_a = param.as) !== null && _a !== void 0 ? _a : param.query._coll,\n            one: (_b = param.one) !== null && _b !== void 0 ? _b : false\n        };\n        const combinedWiths = this._withs.concat(newWith);\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, this._queryOptions, combinedWiths);\n    }\n    /**\n     * 添加 一对一 子查询条件\n     * @param param {WithParam}\n     * @returns Query\n     */\n    withOne(param) {\n        var _a;\n        const newWith = {\n            query: param.query,\n            foreignField: param.foreignField,\n            localField: param.localField,\n            as: (_a = param.as) !== null && _a !== void 0 ? _a : param.query._coll,\n            one: true\n        };\n        const combinedWiths = this._withs.concat(newWith);\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, this._queryOptions, combinedWiths);\n    }\n    /**\n     * 指定要返回的字段\n     *\n     * @param projection\n     */\n    field(projection) {\n        let formatted = {};\n        if (projection instanceof Array) {\n            let result = {};\n            for (let k of projection) {\n                result[k] = 1;\n            }\n            formatted = result;\n        }\n        else {\n            for (let k in projection) {\n                if (projection[k]) {\n                    if (typeof projection[k] !== 'object') {\n                        formatted[k] = 1;\n                    }\n                }\n                else {\n                    formatted[k] = 0;\n                }\n            }\n        }\n        const option = Object.assign({}, this._queryOptions);\n        option.projection = formatted;\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, option, this._withs);\n    }\n    /**\n     * 设置查询条数\n     *\n     * @param limit - 限制条数，当前限制一次请求获取数据条数不得大于 1000\n     */\n    limit(limit) {\n        validate_1.Validate.isInteger('limit', limit);\n        let option = Object.assign({}, this._queryOptions);\n        option.limit = limit;\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, option, this._withs);\n    }\n    /**\n     * 设置偏移量\n     *\n     * @param offset - 偏移量\n     */\n    skip(offset) {\n        validate_1.Validate.isInteger('offset', offset);\n        let option = Object.assign({}, this._queryOptions);\n        option.offset = offset;\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, option, this._withs);\n    }\n    /**\n     * 设置分页查询\n     * @param options { current: number, size: number} `current` 是页码，默认为 `1`, `size` 是每页大小, 默认为 10\n     */\n    page(options) {\n        const current = (options === null || options === void 0 ? void 0 : options.current) || 1;\n        const size = (options === null || options === void 0 ? void 0 : options.size) || 10;\n        const query = this\n            .skip((current - 1) * size)\n            .limit(size);\n        query._queryOptions.count = true;\n        return query;\n    }\n    /**\n     * 克隆\n     * @returns Query\n     */\n    clone() {\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, this._queryOptions, this._withs);\n    }\n    /**\n     * 发起请求获取文档列表\n     *\n     * - 默认 `limit` 为 100\n     * - 可以把通过 `orderBy()`、`where()`、`skip()`、`limit()`设置的数据添加请求参数上\n     */\n    async get() {\n        var _a;\n        if ((_a = this._withs) === null || _a === void 0 ? void 0 : _a.length) {\n            return await this.internalMerge();\n        }\n        else {\n            return await this.internalGet();\n        }\n    }\n    /**\n     * 发起请求获取一个文档\n     * @param options\n     * @returns\n     */\n    async getOne() {\n        const res = await this.limit(1).get();\n        if (res.error) {\n            return res;\n        }\n        if (!res.data.length) {\n            return {\n                ok: true,\n                data: null,\n                requestId: res.requestId\n            };\n        }\n        return {\n            ok: true,\n            data: res.data[0],\n            requestId: res.requestId\n        };\n    }\n    /**\n     * [该接口已废弃，直接使用 `get()` 代替]\n     * 发起请求获取文档列表，当使用 with 条件时使用\n     *\n     * @deprecated\n     *\n     * 1. 调用 get() 执行主查询\n     * 2. 结合主查询的结果，使用 in 执行子表查询\n     * 3. 合并主表 & 子表的结果，即聚合\n     * 4. intersection 可指定是否取两个结果集的交集，缺省则以主表结果为主\n     */\n    async merge(options) {\n        const res = await this.internalMerge(options);\n        return res;\n    }\n    /**\n     * 获取总数\n     */\n    async count() {\n        const param = this.buildQueryParam();\n        const res = await this.send(constant_1.ActionType.count, param);\n        if (res.error) {\n            return {\n                requestId: res.requestId,\n                ok: false,\n                error: res.error,\n                total: undefined,\n                code: res.code\n            };\n        }\n        return {\n            requestId: res.requestId,\n            total: res.data.total,\n            ok: true\n        };\n    }\n    /**\n     * 发起请求批量更新文档\n     *\n     * @param data 数据\n     */\n    async update(data, options) {\n        var _a, _b, _c, _d;\n        if (!data || typeof data !== 'object' || 0 === ((_a = Object.keys(data)) === null || _a === void 0 ? void 0 : _a.length)) {\n            throw new Error('data cannot be empty object');\n        }\n        if (data.hasOwnProperty('_id')) {\n            throw new Error('can not update the `_id` field');\n        }\n        const param = this.buildQueryParam();\n        param.multi = (_b = options === null || options === void 0 ? void 0 : options.multi) !== null && _b !== void 0 ? _b : false;\n        param.merge = (_c = options === null || options === void 0 ? void 0 : options.merge) !== null && _c !== void 0 ? _c : true;\n        param.upsert = (_d = options === null || options === void 0 ? void 0 : options.upsert) !== null && _d !== void 0 ? _d : false;\n        if (param.merge) {\n            param.data = update_1.UpdateSerializer.encode(data);\n        }\n        else {\n            param.data = datatype_1.serialize(data);\n        }\n        const res = await this.send(constant_1.ActionType.update, param);\n        if (res.error) {\n            return {\n                requestId: res.requestId,\n                error: res.error,\n                ok: false,\n                code: res.code,\n                updated: undefined,\n                matched: undefined,\n                upsertId: undefined\n            };\n        }\n        return {\n            requestId: res.requestId,\n            updated: res.data.updated,\n            matched: res.data.matched,\n            upsertId: res.data.upsert_id,\n            ok: true\n        };\n    }\n    /**\n     * 条件删除文档\n     */\n    async remove(options) {\n        var _a, _b;\n        if (Object.keys(this._queryOptions).length > 0) {\n            console.warn('`offset`, `limit` and `projection` are not supported in remove() operation');\n        }\n        if (((_a = this._fieldOrders) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n            console.warn('`orderBy` is not supported in remove() operation');\n        }\n        const param = this.buildQueryParam();\n        param.multi = (_b = options === null || options === void 0 ? void 0 : options.multi) !== null && _b !== void 0 ? _b : false;\n        const res = await this.send(constant_1.ActionType.remove, param);\n        if (res.error) {\n            return {\n                requestId: res.requestId,\n                error: res.error,\n                ok: false,\n                deleted: undefined,\n                code: res.code\n            };\n        }\n        return {\n            requestId: res.requestId,\n            deleted: res.data.deleted,\n            ok: true\n        };\n    }\n    /**\n     * Build query param\n     * @returns\n     */\n    buildQueryParam() {\n        var _a;\n        const param = {\n            collectionName: this._coll,\n        };\n        if (this._fieldFilters) {\n            param.query = this._fieldFilters;\n        }\n        if ((_a = this._fieldOrders) === null || _a === void 0 ? void 0 : _a.length) {\n            param.order = [...this._fieldOrders];\n        }\n        if (this._queryOptions.offset) {\n            param.offset = this._queryOptions.offset;\n        }\n        if (this._queryOptions.limit) {\n            param.limit = this._queryOptions.limit < 1000 ? this._queryOptions.limit : 1000;\n        }\n        else {\n            param.limit = 100;\n        }\n        if (this._queryOptions.projection) {\n            param.projection = this._queryOptions.projection;\n        }\n        if (this._queryOptions.count) {\n            param.count = this._queryOptions.count;\n        }\n        return param;\n    }\n    /**\n    * 发起请求获取文档列表\n    */\n    async internalGet() {\n        var _a, _b, _c;\n        const param = this.buildQueryParam();\n        const res = await this.send(constant_1.ActionType.query, param);\n        if (res.error) {\n            return {\n                error: res.error,\n                data: res.data,\n                requestId: res.requestId,\n                ok: false,\n                code: res.code\n            };\n        }\n        const documents = util_1.Util.formatResDocumentData(res.data.list);\n        const result = {\n            data: documents,\n            requestId: res.requestId,\n            ok: true\n        };\n        if (res.total)\n            result.total = (_a = res.data) === null || _a === void 0 ? void 0 : _a.total;\n        if (res.limit)\n            result.limit = (_b = res.data) === null || _b === void 0 ? void 0 : _b.limit;\n        if (res.offset)\n            result.offset = (_c = res.data) === null || _c === void 0 ? void 0 : _c.offset;\n        return result;\n    }\n    /**\n     * 发起请求获取文档列表，当使用 with 条件时使用\n     *\n     * 1. 调用 internalGet() 执行主查询\n     * 2. 结合主查询的结果，使用 in 执行子表查询\n     * 3. 合并主表 & 子表的结果，即聚合\n     * 4. intersection 可指定是否取两个结果集的交集，缺省则以主表结果为主\n     */\n    async internalMerge(options) {\n        var _a;\n        options = options !== null && options !== void 0 ? options : {};\n        const intersection = (_a = options === null || options === void 0 ? void 0 : options.intersection) !== null && _a !== void 0 ? _a : false;\n        // 调用 get() 执行主查询\n        const res = await this.internalGet();\n        if (!res.ok) {\n            return res;\n        }\n        // 针对每一个 WithParam 做合并处理\n        for (let _with of this._withs) {\n            const { query, localField, foreignField, as, one } = _with;\n            const localValues = res.data.map(localData => localData[localField]);\n            // 处理子查询\n            let q = query.clone();\n            if (!q._fieldFilters) {\n                q._fieldFilters = {};\n            }\n            q._fieldFilters[foreignField] = { '$in': localValues };\n            // 执行子查询\n            let r_sub;\n            if (q._withs.length) {\n                r_sub = await q.merge(); // 如果子查询也使用了 with/withOne，则使用 merge() 查询\n            }\n            else {\n                r_sub = await q.get();\n            }\n            if (!r_sub.ok) {\n                return r_sub;\n            }\n            // 按照 localField -> foreignField 的连接关系将子查询结果聚合：\n            // 1. 构建 { [value of `foreignField`]: [subQueryData] } 映射表\n            const _map = {};\n            for (let sub of r_sub.data) {\n                const key = sub[foreignField]; // 将子表结果的连接键的值做为映射表的 key\n                if (one) {\n                    _map[key] = sub;\n                }\n                else {\n                    _map[key] = _map[key] || [];\n                    _map[key].push(sub); // 将子表结果放入映射表\n                }\n            }\n            // 2. 将聚合结果合并入主表结果集中\n            const results = [];\n            for (let m of res.data) {\n                // 此处主表结果中的 [value of `localField`] 与 上面子表结果中的 [value of `foreignField`] 应该是一致的\n                const key = m[localField];\n                m[as] = _map[key];\n                // 如果取交集且子表结果无对应数据，则丢弃此条数据\n                if (intersection && !_map[key]) {\n                    continue;\n                }\n                results.push(m);\n            }\n            res.data = results;\n        }\n        return res;\n    }\n    /**\n     * Send query request\n     * @param action\n     * @param param\n     * @returns\n     */\n    async send(action, param) {\n        return await this._request.send(action, param);\n    }\n}\nexports.Query = Query;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_1 = require(\"../commands/query\");\nconst logic_1 = require(\"../commands/logic\");\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst operator_map_1 = require(\"../operator-map\");\nconst common_1 = require(\"./common\");\nclass QuerySerializer {\n    constructor() { }\n    static encode(query) {\n        const encoder = new QueryEncoder();\n        return encoder.encodeQuery(query);\n    }\n}\nexports.QuerySerializer = QuerySerializer;\nclass QueryEncoder {\n    encodeQuery(query, key) {\n        if (common_1.isConversionRequired(query)) {\n            if (logic_1.isLogicCommand(query)) {\n                return this.encodeLogicCommand(query);\n            }\n            else if (query_1.isQueryCommand(query)) {\n                return this.encodeQueryCommand(query);\n            }\n            else {\n                return { [key]: this.encodeQueryObject(query) };\n            }\n        }\n        else {\n            if (type_1.isObject(query)) {\n                return this.encodeQueryObject(query);\n            }\n            else {\n                // abnormal case, should not enter this block\n                return query;\n            }\n        }\n    }\n    encodeRegExp(query) {\n        return {\n            $regex: query.source,\n            $options: query.flags\n        };\n    }\n    encodeLogicCommand(query) {\n        switch (query.operator) {\n            case logic_1.LOGIC_COMMANDS_LITERAL.NOR:\n            case logic_1.LOGIC_COMMANDS_LITERAL.AND:\n            case logic_1.LOGIC_COMMANDS_LITERAL.OR: {\n                const $op = operator_map_1.operatorToString(query.operator);\n                const subqueries = query.operands.map(oprand => this.encodeQuery(oprand, query.fieldName));\n                return {\n                    [$op]: subqueries\n                };\n            }\n            case logic_1.LOGIC_COMMANDS_LITERAL.NOT: {\n                const $op = operator_map_1.operatorToString(query.operator);\n                const operatorExpression = query.operands[0];\n                if (type_1.isRegExp(operatorExpression)) {\n                    return {\n                        [query.fieldName]: {\n                            [$op]: this.encodeRegExp(operatorExpression)\n                        }\n                    };\n                }\n                else {\n                    const subqueries = this.encodeQuery(operatorExpression)[query.fieldName];\n                    return {\n                        [query.fieldName]: {\n                            [$op]: subqueries\n                        }\n                    };\n                }\n            }\n            default: {\n                const $op = operator_map_1.operatorToString(query.operator);\n                if (query.operands.length === 1) {\n                    const subquery = this.encodeQuery(query.operands[0]);\n                    return {\n                        [$op]: subquery\n                    };\n                }\n                else {\n                    const subqueries = query.operands.map(this.encodeQuery.bind(this));\n                    return {\n                        [$op]: subqueries\n                    };\n                }\n            }\n        }\n    }\n    encodeQueryCommand(query) {\n        if (query_1.isComparisonCommand(query)) {\n            return this.encodeComparisonCommand(query);\n        }\n        else {\n            // TODO: when more command types are added, change it here\n            return this.encodeComparisonCommand(query);\n        }\n    }\n    encodeComparisonCommand(query) {\n        if (query.fieldName === symbol_1.SYMBOL_UNSET_FIELD_NAME) {\n            throw new Error('Cannot encode a comparison command with unset field name');\n        }\n        const $op = operator_map_1.operatorToString(query.operator);\n        switch (query.operator) {\n            case query_1.QUERY_COMMANDS_LITERAL.EQ:\n            case query_1.QUERY_COMMANDS_LITERAL.NEQ:\n            case query_1.QUERY_COMMANDS_LITERAL.LT:\n            case query_1.QUERY_COMMANDS_LITERAL.LTE:\n            case query_1.QUERY_COMMANDS_LITERAL.GT:\n            case query_1.QUERY_COMMANDS_LITERAL.GTE:\n            case query_1.QUERY_COMMANDS_LITERAL.ELEM_MATCH:\n            case query_1.QUERY_COMMANDS_LITERAL.EXISTS:\n            case query_1.QUERY_COMMANDS_LITERAL.SIZE:\n            case query_1.QUERY_COMMANDS_LITERAL.MOD: {\n                return {\n                    [query.fieldName]: {\n                        [$op]: common_1.encodeInternalDataType(query.operands[0])\n                    }\n                };\n            }\n            case query_1.QUERY_COMMANDS_LITERAL.IN:\n            case query_1.QUERY_COMMANDS_LITERAL.NIN:\n            case query_1.QUERY_COMMANDS_LITERAL.ALL: {\n                return {\n                    [query.fieldName]: {\n                        [$op]: common_1.encodeInternalDataType(query.operands)\n                    }\n                };\n            }\n            case query_1.QUERY_COMMANDS_LITERAL.GEO_NEAR: {\n                const options = query.operands[0];\n                return {\n                    [query.fieldName]: {\n                        $nearSphere: {\n                            $geometry: options.geometry.toJSON(),\n                            $maxDistance: options.maxDistance,\n                            $minDistance: options.minDistance\n                        }\n                    }\n                };\n            }\n            case query_1.QUERY_COMMANDS_LITERAL.GEO_WITHIN: {\n                const options = query.operands[0];\n                return {\n                    [query.fieldName]: {\n                        $geoWithin: {\n                            $geometry: options.geometry.toJSON()\n                        }\n                    }\n                };\n            }\n            case query_1.QUERY_COMMANDS_LITERAL.GEO_INTERSECTS: {\n                const options = query.operands[0];\n                return {\n                    [query.fieldName]: {\n                        $geoIntersects: {\n                            $geometry: options.geometry.toJSON()\n                        }\n                    }\n                };\n            }\n            default: {\n                return {\n                    [query.fieldName]: {\n                        [$op]: common_1.encodeInternalDataType(query.operands[0])\n                    }\n                };\n            }\n        }\n    }\n    encodeQueryObject(query) {\n        const flattened = common_1.flattenQueryObject(query);\n        for (const key in flattened) {\n            const val = flattened[key];\n            if (logic_1.isLogicCommand(val)) {\n                flattened[key] = val._setFieldName(key);\n                const condition = this.encodeLogicCommand(flattened[key]);\n                this.mergeConditionAfterEncode(flattened, condition, key);\n            }\n            else if (query_1.isComparisonCommand(val)) {\n                flattened[key] = val._setFieldName(key);\n                const condition = this.encodeComparisonCommand(flattened[key]);\n                this.mergeConditionAfterEncode(flattened, condition, key);\n            }\n            else if (common_1.isConversionRequired(val)) {\n                flattened[key] = common_1.encodeInternalDataType(val);\n            }\n        }\n        return flattened;\n    }\n    /**\n     * @description Merge 2 query conditions\n     * @example\n     *\n     * Normal cases:\n     *\n     * C1. merge top-level commands, such as $and and $or:\n     * let A = { $and: [{a: 1}] }\n     * let B = { $and: [{b: 2}] }\n     * merge(A, B) == { $and: [{a: 1}, {b: 2}] }\n     *\n     * C2. merge top-level fields\n     * let A = { a: { $gt: 1 } }\n     * let B = { a: { $lt: 5 } }\n     * merge(A, B) == { a: { $gt: 1, $lt: 5 } }\n     *\n     * Edge cases:\n     *\n     * E1. unmergable top-level fields\n     * Solution: override\n     * let A = { a: 1 }\n     * let B = { a: { $gt: 1 } }\n     * merge(A, B) == B\n     *\n     * @param query\n     * @param condition\n     * @param key\n     */\n    mergeConditionAfterEncode(query, condition, key) {\n        if (!condition[key]) {\n            delete query[key];\n        }\n        for (const conditionKey in condition) {\n            if (query[conditionKey]) {\n                if (type_1.isArray(query[conditionKey])) {\n                    // bug\n                    query[conditionKey] = query[conditionKey].concat(condition[conditionKey]);\n                }\n                else if (type_1.isObject(query[conditionKey])) {\n                    if (type_1.isObject(condition[conditionKey])) {\n                        Object.assign(query, condition);\n                    }\n                    else {\n                        console.warn(`unmergable condition, query is object but condition is ${type_1.getType(condition)}, can only overwrite`, condition, key);\n                        query[conditionKey] = condition[conditionKey];\n                    }\n                }\n                else {\n                    console.warn(`to-merge query is of type ${type_1.getType(query)}, can only overwrite`, query, condition, key);\n                    query[conditionKey] = condition[conditionKey];\n                }\n            }\n            else {\n                query[conditionKey] = condition[conditionKey];\n            }\n        }\n    }\n}\n/**\n\n{\n  prop: {\n    mem: _.gt(4).and(_.lt(8)),\n  },\n  price: _.lt(5000).and(_.gt(3000))\n}\n\n=>\n\n{\n  prop: {\n    mem: $and([\n      $gt(4),\n      $lt(8),\n    ])\n  },\n  price: $and([\n    $lt(5000),\n    $gt(3000),\n  ])\n}\n\n=>\n\n{\n  $and: [\n    {\n      'prop.mem': {\n        $gt: 4,\n        $lt: 8\n      }\n    },\n    {\n      'price': {\n        $gt: 3000,\n        $lt: 5000\n      }\n    }\n  ]\n}\n\n */\n/**\n\n_.or([\n  {\n    category: 'pc'\n    prop: {\n      mem: _.gt(8).and(_.lt(16)).or(_.eq(32))\n    },\n  },\n  {\n    category: 'pc'\n    prop: {\n      cpu: _.gt(3.2)\n    }\n  }\n])\n\n=>\n\n_.or([\n  {\n    category: 'pc',\n    prop: {\n      mem: $or([\n        $and([\n          $gt(8),\n          $lt(16),\n        ]),\n        $eq(32)\n      ])\n    }\n  },\n  {\n    category: 'pc',\n    prop: {\n      cpu: $gt(3.2)\n    }\n  }\n])\n\n=>\n\n{\n  $or: [\n    {\n      //...\n    },\n    {\n      //...\n    }\n  ]\n}\n\n=>\n\n{\n  $or: [\n    {\n      category: 'pc',\n      $or: [\n        $and: [\n          'prop.mem': {\n            $gt: 8,\n            $lt: 16,\n          },\n        ],\n        'prop.mem': {\n          $eq: 32\n        }\n      ]\n    },\n    {\n      category: 'pc',\n      'prop.cpu': {\n        $eq: 3.2\n      }\n    }\n  ]\n}\n\n */\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logic_1 = require(\"./logic\");\nconst symbol_1 = require(\"../helper/symbol\");\nconst index_1 = require(\"../geo/index\");\nconst type_1 = require(\"../utils/type\");\nexports.EQ = 'eq';\nexports.NEQ = 'neq';\nexports.GT = 'gt';\nexports.GTE = 'gte';\nexports.LT = 'lt';\nexports.LTE = 'lte';\nexports.IN = 'in';\nexports.NIN = 'nin';\nexports.ALL = 'all';\nexports.ELEM_MATCH = 'elemMatch';\nexports.EXISTS = 'exists';\nexports.SIZE = 'size';\nexports.MOD = 'mod';\nexports.LIKE = 'like';\nvar QUERY_COMMANDS_LITERAL;\n(function (QUERY_COMMANDS_LITERAL) {\n    QUERY_COMMANDS_LITERAL[\"EQ\"] = \"eq\";\n    QUERY_COMMANDS_LITERAL[\"NEQ\"] = \"neq\";\n    QUERY_COMMANDS_LITERAL[\"GT\"] = \"gt\";\n    QUERY_COMMANDS_LITERAL[\"GTE\"] = \"gte\";\n    QUERY_COMMANDS_LITERAL[\"LT\"] = \"lt\";\n    QUERY_COMMANDS_LITERAL[\"LTE\"] = \"lte\";\n    QUERY_COMMANDS_LITERAL[\"IN\"] = \"in\";\n    QUERY_COMMANDS_LITERAL[\"NIN\"] = \"nin\";\n    QUERY_COMMANDS_LITERAL[\"ALL\"] = \"all\";\n    QUERY_COMMANDS_LITERAL[\"ELEM_MATCH\"] = \"elemMatch\";\n    QUERY_COMMANDS_LITERAL[\"EXISTS\"] = \"exists\";\n    QUERY_COMMANDS_LITERAL[\"SIZE\"] = \"size\";\n    QUERY_COMMANDS_LITERAL[\"MOD\"] = \"mod\";\n    QUERY_COMMANDS_LITERAL[\"GEO_NEAR\"] = \"geoNear\";\n    QUERY_COMMANDS_LITERAL[\"GEO_WITHIN\"] = \"geoWithin\";\n    QUERY_COMMANDS_LITERAL[\"GEO_INTERSECTS\"] = \"geoIntersects\";\n    QUERY_COMMANDS_LITERAL[\"LIKE\"] = \"like\";\n})(QUERY_COMMANDS_LITERAL = exports.QUERY_COMMANDS_LITERAL || (exports.QUERY_COMMANDS_LITERAL = {}));\nclass QueryCommand extends logic_1.LogicCommand {\n    constructor(operator, operands, fieldName) {\n        super(operator, operands, fieldName);\n        this.operator = operator;\n        this._internalType = symbol_1.SYMBOL_QUERY_COMMAND;\n    }\n    toJSON() {\n        switch (this.operator) {\n            case QUERY_COMMANDS_LITERAL.IN:\n            case QUERY_COMMANDS_LITERAL.NIN:\n                return {\n                    ['$' + this.operator]: this.operands\n                };\n            default:\n                return {\n                    ['$' + this.operator]: this.operands[0]\n                };\n        }\n    }\n    _setFieldName(fieldName) {\n        const command = new QueryCommand(this.operator, this.operands, fieldName);\n        return command;\n    }\n    eq(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.EQ, [val], this.fieldName);\n        return this.and(command);\n    }\n    neq(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.NEQ, [val], this.fieldName);\n        return this.and(command);\n    }\n    gt(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GT, [val], this.fieldName);\n        return this.and(command);\n    }\n    gte(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GTE, [val], this.fieldName);\n        return this.and(command);\n    }\n    lt(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.LT, [val], this.fieldName);\n        return this.and(command);\n    }\n    lte(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.LTE, [val], this.fieldName);\n        return this.and(command);\n    }\n    in(list) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.IN, list, this.fieldName);\n        return this.and(command);\n    }\n    nin(list) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.NIN, list, this.fieldName);\n        return this.and(command);\n    }\n    geoNear(val) {\n        if (!(val.geometry instanceof index_1.Point)) {\n            throw new TypeError(`\"geometry\" must be of type Point. Received type ${typeof val.geometry}`);\n        }\n        if (val.maxDistance !== undefined && !type_1.isNumber(val.maxDistance)) {\n            throw new TypeError(`\"maxDistance\" must be of type Number. Received type ${typeof val.maxDistance}`);\n        }\n        if (val.minDistance !== undefined && !type_1.isNumber(val.minDistance)) {\n            throw new TypeError(`\"minDistance\" must be of type Number. Received type ${typeof val.minDistance}`);\n        }\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_NEAR, [val], this.fieldName);\n        return this.and(command);\n    }\n    geoWithin(val) {\n        if (!(val.geometry instanceof index_1.MultiPolygon) && !(val.geometry instanceof index_1.Polygon)) {\n            throw new TypeError(`\"geometry\" must be of type Polygon or MultiPolygon. Received type ${typeof val.geometry}`);\n        }\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_WITHIN, [val], this.fieldName);\n        return this.and(command);\n    }\n    geoIntersects(val) {\n        if (!(val.geometry instanceof index_1.Point) &&\n            !(val.geometry instanceof index_1.LineString) &&\n            !(val.geometry instanceof index_1.Polygon) &&\n            !(val.geometry instanceof index_1.MultiPoint) &&\n            !(val.geometry instanceof index_1.MultiLineString) &&\n            !(val.geometry instanceof index_1.MultiPolygon)) {\n            throw new TypeError(`\"geometry\" must be of type Point, LineString, Polygon, MultiPoint, MultiLineString or MultiPolygon. Received type ${typeof val.geometry}`);\n        }\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_INTERSECTS, [val], this.fieldName);\n        return this.and(command);\n    }\n}\nexports.QueryCommand = QueryCommand;\nfunction isQueryCommand(object) {\n    return object && object instanceof QueryCommand && object._internalType === symbol_1.SYMBOL_QUERY_COMMAND;\n}\nexports.isQueryCommand = isQueryCommand;\nfunction isKnownQueryCommand(object) {\n    return isQueryCommand(object) && object.operator.toUpperCase() in QUERY_COMMANDS_LITERAL;\n}\nexports.isKnownQueryCommand = isKnownQueryCommand;\nfunction isComparisonCommand(object) {\n    return isQueryCommand(object);\n}\nexports.isComparisonCommand = isComparisonCommand;\nexports.default = QueryCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst query_1 = require(\"./query\");\nexports.AND = 'and';\nexports.OR = 'or';\nexports.NOT = 'not';\nexports.NOR = 'nor';\nvar LOGIC_COMMANDS_LITERAL;\n(function (LOGIC_COMMANDS_LITERAL) {\n    LOGIC_COMMANDS_LITERAL[\"AND\"] = \"and\";\n    LOGIC_COMMANDS_LITERAL[\"OR\"] = \"or\";\n    LOGIC_COMMANDS_LITERAL[\"NOT\"] = \"not\";\n    LOGIC_COMMANDS_LITERAL[\"NOR\"] = \"nor\";\n})(LOGIC_COMMANDS_LITERAL = exports.LOGIC_COMMANDS_LITERAL || (exports.LOGIC_COMMANDS_LITERAL = {}));\nclass LogicCommand {\n    constructor(operator, operands, fieldName) {\n        this._internalType = symbol_1.SYMBOL_LOGIC_COMMAND;\n        Object.defineProperties(this, {\n            _internalType: {\n                enumerable: false,\n                configurable: false,\n            },\n        });\n        this.operator = operator;\n        this.operands = operands;\n        this.fieldName = fieldName || symbol_1.SYMBOL_UNSET_FIELD_NAME;\n        if (this.fieldName !== symbol_1.SYMBOL_UNSET_FIELD_NAME) {\n            if (Array.isArray(operands)) {\n                operands = operands.slice();\n                this.operands = operands;\n                for (let i = 0, len = operands.length; i < len; i++) {\n                    const query = operands[i];\n                    if (isLogicCommand(query) || query_1.isQueryCommand(query)) {\n                        operands[i] = query._setFieldName(this.fieldName);\n                    }\n                }\n            }\n            else {\n                const query = operands;\n                if (isLogicCommand(query) || query_1.isQueryCommand(query)) {\n                    operands = query._setFieldName(this.fieldName);\n                }\n            }\n        }\n        /*\n        Object.defineProperties(this, {\n          operator: {\n            configurable: true,\n            enumerable: true,\n            writable: false,\n            value: operator,\n          },\n          operands: {\n            configurable: true,\n            enumerable: true,\n            writable: false,\n            value: operands,\n          },\n          fieldName: {\n            configurable: true,\n            enumerable: true,\n            get() {\n              return _fieldName\n            },\n            set(val) {\n              _fieldName = val\n            }\n          }\n        })\n        */\n    }\n    _setFieldName(fieldName) {\n        const operands = this.operands.map(operand => {\n            if (operand instanceof LogicCommand) {\n                return operand._setFieldName(fieldName);\n            }\n            else {\n                return operand;\n            }\n        });\n        const command = new LogicCommand(this.operator, operands, fieldName);\n        return command;\n    }\n    /**\n     * Support only command[] or ...command in v1\n     * @param {(LogicCommand[]|object[]|...LogicCommand|...object)} expressions Command[] or ...Command\n     */\n    and(...__expressions__) {\n        const expressions = Array.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        expressions.unshift(this);\n        return new LogicCommand(LOGIC_COMMANDS_LITERAL.AND, expressions, this.fieldName);\n    }\n    /**\n     * Support only command[] or ...command in v1\n     * @param {(LogicCommand[]|object[]|...LogicCommand|...object)} expressions Command[] or ...Command\n     */\n    or(...__expressions__) {\n        const expressions = Array.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        expressions.unshift(this);\n        return new LogicCommand(LOGIC_COMMANDS_LITERAL.OR, expressions, this.fieldName);\n    }\n}\nexports.LogicCommand = LogicCommand;\nfunction isLogicCommand(object) {\n    return object && (object instanceof LogicCommand) && (object._internalType === symbol_1.SYMBOL_LOGIC_COMMAND);\n}\nexports.isLogicCommand = isLogicCommand;\nfunction isKnownLogicCommand(object) {\n    return isLogicCommand && (object.operator.toUpperCase() in LOGIC_COMMANDS_LITERAL);\n}\nexports.isKnownLogicCommand = isKnownLogicCommand;\nexports.default = LogicCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_1 = require(\"./commands/query\");\nconst logic_1 = require(\"./commands/logic\");\nconst update_1 = require(\"./commands/update\");\nexports.OperatorMap = {};\nfor (const key in query_1.QUERY_COMMANDS_LITERAL) {\n    exports.OperatorMap[key] = '$' + key;\n}\nfor (const key in logic_1.LOGIC_COMMANDS_LITERAL) {\n    exports.OperatorMap[key] = '$' + key;\n}\nfor (const key in update_1.UPDATE_COMMANDS_LITERAL) {\n    exports.OperatorMap[key] = '$' + key;\n}\n// some exceptions\nexports.OperatorMap[query_1.QUERY_COMMANDS_LITERAL.NEQ] = '$ne';\nexports.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.REMOVE] = '$unset';\nexports.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.SHIFT] = '$pop'; // same as POP\nexports.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT] = '$push'; // same as PUSH\nfunction operatorToString(operator) {\n    return exports.OperatorMap[operator] || '$' + operator;\n}\nexports.operatorToString = operatorToString;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst type_1 = require(\"../utils/type\");\nconst datatype_1 = require(\"./datatype\");\nfunction flatten(query, shouldPreserverObject, parents, visited) {\n    const cloned = Object.assign({}, query);\n    for (const key in query) {\n        if (/^\\$/.test(key))\n            continue;\n        const value = query[key];\n        if (!value)\n            continue;\n        if (type_1.isObject(value) && !shouldPreserverObject(value)) {\n            if (visited.indexOf(value) > -1) {\n                throw new Error('Cannot convert circular structure to JSON');\n            }\n            const newParents = [\n                ...parents,\n                key,\n            ];\n            const newVisited = [\n                ...visited,\n                value,\n            ];\n            const flattenedChild = flatten(value, shouldPreserverObject, newParents, newVisited);\n            cloned[key] = flattenedChild;\n            let hasKeyNotCombined = false;\n            for (const childKey in flattenedChild) {\n                if (!/^\\$/.test(childKey)) {\n                    cloned[`${key}.${childKey}`] = flattenedChild[childKey];\n                    delete cloned[key][childKey];\n                }\n                else {\n                    hasKeyNotCombined = true;\n                }\n            }\n            if (!hasKeyNotCombined) {\n                delete cloned[key];\n            }\n        }\n    }\n    return cloned;\n}\nfunction flattenQueryObject(query) {\n    return flatten(query, isConversionRequired, [], [query]);\n}\nexports.flattenQueryObject = flattenQueryObject;\nfunction flattenObject(object) {\n    return flatten(object, (_) => false, [], [object]);\n}\nexports.flattenObject = flattenObject;\nfunction mergeConditionAfterEncode(query, condition, key) {\n    if (!condition[key]) {\n        delete query[key];\n    }\n    for (const conditionKey in condition) {\n        if (query[conditionKey]) {\n            if (type_1.isArray(query[conditionKey])) {\n                query[conditionKey].push(condition[conditionKey]);\n            }\n            else if (type_1.isObject(query[conditionKey])) {\n                if (type_1.isObject(condition[conditionKey])) {\n                    Object.assign(query[conditionKey], condition[conditionKey]);\n                }\n                else {\n                    console.warn(`unmergable condition, query is object but condition is ${type_1.getType(condition)}, can only overwrite`, condition, key);\n                    query[conditionKey] = condition[conditionKey];\n                }\n            }\n            else {\n                console.warn(`to-merge query is of type ${type_1.getType(query)}, can only overwrite`, query, condition, key);\n                query[conditionKey] = condition[conditionKey];\n            }\n        }\n        else {\n            query[conditionKey] = condition[conditionKey];\n        }\n    }\n}\nexports.mergeConditionAfterEncode = mergeConditionAfterEncode;\n/**\n * Check `val` if `InternalObject` | `Date` | `RegExp` | `ObjectId` | `isBinary`\n * InternalObject can be:  `LogicCommand` | `QueryCommand` | `UpdateCommand`\n *\n * @tip this method also used is `flatten()` function, `flatten` will reserved the required object\n * @param val\n * @returns\n */\nfunction isConversionRequired(val) {\n    return type_1.isInternalObject(val) || type_1.isDate(val) || type_1.isRegExp(val) || type_1.isObjectId(val) || type_1.isBinary(val);\n}\nexports.isConversionRequired = isConversionRequired;\nfunction encodeInternalDataType(val) {\n    return datatype_1.serialize(val);\n}\nexports.encodeInternalDataType = encodeInternalDataType;\nfunction decodeInternalDataType(object) {\n    return datatype_1.deserialize(object);\n}\nexports.decodeInternalDataType = decodeInternalDataType;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst update_1 = require(\"../commands/update\");\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst operator_map_1 = require(\"../operator-map\");\nconst common_1 = require(\"./common\");\nclass UpdateSerializer {\n    constructor() { }\n    static encode(query) {\n        const stringifier = new UpdateSerializer();\n        return stringifier.encodeUpdate(query);\n    }\n    encodeUpdate(query) {\n        if (update_1.isUpdateCommand(query)) {\n            return this.encodeUpdateCommand(query);\n        }\n        else if (type_1.getType(query) === 'object') {\n            return this.encodeUpdateObject(query);\n        }\n        else {\n            return query;\n        }\n    }\n    encodeUpdateCommand(query) {\n        if (query.fieldName === symbol_1.SYMBOL_UNSET_FIELD_NAME) {\n            throw new Error('Cannot encode a comparison command with unset field name');\n        }\n        switch (query.operator) {\n            case update_1.UPDATE_COMMANDS_LITERAL.PUSH:\n            case update_1.UPDATE_COMMANDS_LITERAL.PULL:\n            case update_1.UPDATE_COMMANDS_LITERAL.PULL_ALL:\n            case update_1.UPDATE_COMMANDS_LITERAL.POP:\n            case update_1.UPDATE_COMMANDS_LITERAL.SHIFT:\n            case update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT:\n            case update_1.UPDATE_COMMANDS_LITERAL.ADD_TO_SET: {\n                return this.encodeArrayUpdateCommand(query);\n            }\n            default: {\n                return this.encodeFieldUpdateCommand(query);\n            }\n        }\n    }\n    encodeFieldUpdateCommand(query) {\n        const $op = operator_map_1.operatorToString(query.operator);\n        switch (query.operator) {\n            case update_1.UPDATE_COMMANDS_LITERAL.REMOVE: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: ''\n                    }\n                };\n            }\n            default: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: query.operands[0]\n                    }\n                };\n            }\n        }\n    }\n    encodeArrayUpdateCommand(query) {\n        const $op = operator_map_1.operatorToString(query.operator);\n        switch (query.operator) {\n            case update_1.UPDATE_COMMANDS_LITERAL.PUSH: {\n                let modifiers;\n                if (type_1.isArray(query.operands)) {\n                    modifiers = {\n                        $each: query.operands.map(common_1.encodeInternalDataType)\n                    };\n                }\n                else {\n                    modifiers = query.operands;\n                }\n                return {\n                    [$op]: {\n                        [query.fieldName]: modifiers\n                    }\n                };\n            }\n            case update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT: {\n                const modifiers = {\n                    $each: query.operands.map(common_1.encodeInternalDataType),\n                    $position: 0\n                };\n                return {\n                    [$op]: {\n                        [query.fieldName]: modifiers\n                    }\n                };\n            }\n            case update_1.UPDATE_COMMANDS_LITERAL.POP: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: 1\n                    }\n                };\n            }\n            case update_1.UPDATE_COMMANDS_LITERAL.SHIFT: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: -1\n                    }\n                };\n            }\n            default: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: common_1.encodeInternalDataType(query.operands)\n                    }\n                };\n            }\n        }\n    }\n    encodeUpdateObject(query) {\n        const flattened = common_1.flattenQueryObject(query);\n        for (const key in flattened) {\n            if (/^\\$/.test(key))\n                continue;\n            let val = flattened[key];\n            if (update_1.isUpdateCommand(val)) {\n                flattened[key] = val._setFieldName(key);\n                const condition = this.encodeUpdateCommand(flattened[key]);\n                common_1.mergeConditionAfterEncode(flattened, condition, key);\n            }\n            else {\n                // $set\n                flattened[key] = val = common_1.encodeInternalDataType(val);\n                const $setCommand = new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.SET, [val], key);\n                const condition = this.encodeUpdateCommand($setCommand);\n                common_1.mergeConditionAfterEncode(flattened, condition, key);\n            }\n        }\n        return flattened;\n    }\n}\nexports.UpdateSerializer = UpdateSerializer;\n/**\n\n{\n  a: {\n    a1: _.set({ a11: 'test' }),\n    a2: _.inc(10)\n  },\n}\n\n=>\n\n{\n  a: {\n    a1: $set({ a11: 'test' }),\n    a2: $inc(10)\n  }\n}\n\n=>\n\n{\n  'a.a1': $set({ a11: 'test' }),\n  'a.a2': $inc(10)\n}\n\n=>\n\n{\n  $set: {\n    'a.a1': {\n      a11: 'test'\n    }\n  },\n  $inc: {\n    'a.a2': 10\n  }\n}\n\n*/\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_1 = require(\"./serializer/query\");\nconst utils_1 = require(\"./utils/utils\");\nconst type_1 = require(\"./utils/type\");\nconst validate_1 = require(\"./validate\");\nconst constant_1 = require(\"./constant\");\nconst util_1 = require(\"./util\");\nconst EARTH_RADIUS = 6378100;\nclass Aggregation {\n    constructor(db, collectionName, rawPipeline) {\n        this._stages = [];\n        if (db && collectionName) {\n            this._db = db;\n            this._request = this._db.request;\n            this._collectionName = collectionName;\n            if (rawPipeline && rawPipeline.length > 0) {\n                rawPipeline.forEach((stage) => {\n                    validate_1.Validate.isValidAggregation(stage);\n                    const stageName = Object.keys(stage)[0];\n                    this._pipe(stageName, stage[stageName], true);\n                });\n            }\n        }\n    }\n    async end() {\n        var _a;\n        if (!this._collectionName || !this._db) {\n            throw new Error('Aggregation pipeline cannot send request');\n        }\n        if (!((_a = this._stages) === null || _a === void 0 ? void 0 : _a.length)) {\n            throw new Error('Aggregation stage cannot be empty');\n        }\n        const res = await this._request.send(constant_1.ActionType.aggregate, {\n            collectionName: this._collectionName,\n            stages: this._stages\n        });\n        if (res.error) {\n            return {\n                error: res.error,\n                data: res.data,\n                requestId: res.requestId,\n                ok: false,\n                code: res.code\n            };\n        }\n        const documents = util_1.Util.formatResDocumentData(res.data.list);\n        const result = {\n            data: documents,\n            requestId: res.requestId,\n            ok: true\n        };\n        return result;\n    }\n    unwrap() {\n        return this._stages;\n    }\n    done() {\n        return this._stages.map(({ stageKey, stageValue }) => {\n            return {\n                [stageKey]: JSON.parse(stageValue)\n            };\n        });\n    }\n    _pipe(stage, param, raw = false) {\n        // 区分param是否为字符串\n        let transformParam = '';\n        if (type_1.getType(param) === 'object') {\n            transformParam = utils_1.stringifyByEJSON(param);\n        }\n        else {\n            transformParam = JSON.stringify(param);\n        }\n        this._stages.push({\n            stageKey: raw ? stage : `$${stage}`,\n            stageValue: transformParam\n        });\n        return this;\n    }\n    addFields(param) {\n        return this._pipe('addFields', param);\n    }\n    bucket(param) {\n        return this._pipe('bucket', param);\n    }\n    bucketAuto(param) {\n        return this._pipe('bucketAuto', param);\n    }\n    count(param) {\n        return this._pipe('count', param);\n    }\n    geoNear(param) {\n        if (param.query) {\n            param.query = query_1.QuerySerializer.encode(param.query);\n        }\n        // 判断是否有 distanceMultiplier 参数\n        if (param.distanceMultiplier && typeof (param.distanceMultiplier) === 'number') {\n            param.distanceMultiplier = param.distanceMultiplier * EARTH_RADIUS;\n        }\n        else {\n            param.distanceMultiplier = EARTH_RADIUS;\n        }\n        return this._pipe('geoNear', param);\n    }\n    group(param) {\n        return this._pipe('group', param);\n    }\n    limit(param) {\n        return this._pipe('limit', param);\n    }\n    match(param) {\n        return this._pipe('match', query_1.QuerySerializer.encode(param));\n    }\n    project(param) {\n        return this._pipe('project', param);\n    }\n    lookup(param) {\n        return this._pipe('lookup', param);\n    }\n    replaceRoot(param) {\n        return this._pipe('replaceRoot', param);\n    }\n    sample(param) {\n        return this._pipe('sample', param);\n    }\n    skip(param) {\n        return this._pipe('skip', param);\n    }\n    sort(param) {\n        return this._pipe('sort', param);\n    }\n    sortByCount(param) {\n        return this._pipe('sortByCount', param);\n    }\n    unwind(param) {\n        return this._pipe('unwind', param);\n    }\n}\nexports.default = Aggregation;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bson_1 = require(\"bson\");\nconst type_1 = require(\"./type\");\nexports.sleep = (ms = 0) => new Promise(r => setTimeout(r, ms));\nconst counters = {};\nexports.autoCount = (domain = 'any') => {\n    if (!counters[domain]) {\n        counters[domain] = 0;\n    }\n    return counters[domain]++;\n};\n// 递归过滤对象中的undefiend字段\nexports.filterUndefined = o => {\n    // 如果不是对象类型，直接返回\n    if (!type_1.isObject(o)) {\n        return o;\n    }\n    for (let key in o) {\n        if (o[key] === undefined) {\n            delete o[key];\n        }\n        else if (type_1.isObject(o[key])) {\n            o[key] = exports.filterUndefined(o[key]);\n        }\n    }\n    return o;\n};\nexports.stringifyByEJSON = params => {\n    // params中删除undefined的key\n    params = exports.filterUndefined(params);\n    return bson_1.EJSON.stringify(params, { relaxed: false });\n};\nexports.parseByEJSON = params => {\n    return bson_1.EJSON.parse(params);\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_1 = require(\"./commands/query\");\nconst logic_1 = require(\"./commands/logic\");\nconst update_1 = require(\"./commands/update\");\nconst type_1 = require(\"./utils/type\");\nconst aggregate_1 = require(\"./aggregate\");\nexports.Command = {\n    eq(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.EQ, [val]);\n    },\n    neq(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.NEQ, [val]);\n    },\n    lt(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.LT, [val]);\n    },\n    lte(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.LTE, [val]);\n    },\n    gt(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GT, [val]);\n    },\n    gte(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GTE, [val]);\n    },\n    in(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.IN, val);\n    },\n    nin(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.NIN, val);\n    },\n    all(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.ALL, val);\n    },\n    elemMatch(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.ELEM_MATCH, [val]);\n    },\n    exists(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.EXISTS, [val]);\n    },\n    size(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.SIZE, [val]);\n    },\n    mod(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.MOD, [val]);\n    },\n    geoNear(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GEO_NEAR, [val]);\n    },\n    geoWithin(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GEO_WITHIN, [val]);\n    },\n    geoIntersects(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GEO_INTERSECTS, [val]);\n    },\n    like(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.LIKE, [val]);\n    },\n    and(...__expressions__) {\n        const expressions = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new logic_1.LogicCommand(logic_1.LOGIC_COMMANDS_LITERAL.AND, expressions);\n    },\n    nor(...__expressions__) {\n        const expressions = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new logic_1.LogicCommand(logic_1.LOGIC_COMMANDS_LITERAL.NOR, expressions);\n    },\n    or(...__expressions__) {\n        const expressions = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new logic_1.LogicCommand(logic_1.LOGIC_COMMANDS_LITERAL.OR, expressions);\n    },\n    not(...__expressions__) {\n        const expressions = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new logic_1.LogicCommand(logic_1.LOGIC_COMMANDS_LITERAL.NOT, expressions);\n    },\n    set(val) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.SET, [val]);\n    },\n    remove() {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.REMOVE, []);\n    },\n    inc(val) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.INC, [val]);\n    },\n    mul(val) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.MUL, [val]);\n    },\n    push(...args) {\n        let values;\n        if (type_1.isObject(args[0]) && args[0].hasOwnProperty('each')) {\n            const options = args[0];\n            values = {\n                $each: options.each,\n                $position: options.position,\n                $sort: options.sort,\n                $slice: options.slice\n            };\n        }\n        else if (type_1.isArray(args[0])) {\n            values = args[0];\n        }\n        else {\n            values = Array.from(args);\n        }\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.PUSH, values);\n    },\n    pull(values) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.PULL, values);\n    },\n    pullAll(values) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.PULL_ALL, values);\n    },\n    pop() {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.POP, []);\n    },\n    shift() {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.SHIFT, []);\n    },\n    unshift(...__values__) {\n        const values = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT, values);\n    },\n    addToSet(values) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.ADD_TO_SET, values);\n    },\n    rename(values) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.RENAME, [values]);\n    },\n    bit(values) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.BIT, [values]);\n    },\n    max(values) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.MAX, [values]);\n    },\n    min(values) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.MIN, [values]);\n    },\n    expr(values) {\n        return {\n            $expr: values\n        };\n    },\n    jsonSchema(schema) {\n        return {\n            $jsonSchema: schema\n        };\n    },\n    text(values) {\n        if (type_1.isString(values)) {\n            return {\n                $search: values.search\n            };\n        }\n        else {\n            return {\n                $search: values.search,\n                $language: values.language,\n                $caseSensitive: values.caseSensitive,\n                $diacriticSensitive: values.diacriticSensitive\n            };\n        }\n    },\n    aggregate: {\n        pipeline() {\n            return new aggregate_1.default();\n        },\n        // https://docs.mongodb.com/manual/reference/operator/aggregation/\n        // 算数操作符（15个）\n        abs: (param) => new AggregationOperator('abs', param),\n        add: (param) => new AggregationOperator('add', param),\n        ceil: (param) => new AggregationOperator('ceil', param),\n        divide: (param) => new AggregationOperator('divide', param),\n        exp: (param) => new AggregationOperator('exp', param),\n        floor: (param) => new AggregationOperator('floor', param),\n        ln: (param) => new AggregationOperator('ln', param),\n        log: (param) => new AggregationOperator('log', param),\n        log10: (param) => new AggregationOperator('log10', param),\n        mod: (param) => new AggregationOperator('mod', param),\n        multiply: (param) => new AggregationOperator('multiply', param),\n        pow: (param) => new AggregationOperator('pow', param),\n        sqrt: (param) => new AggregationOperator('sqrt', param),\n        subtract: (param) => new AggregationOperator('subtract', param),\n        trunc: (param) => new AggregationOperator('trunc', param),\n        // 数组操作符（15个）\n        arrayElemAt: (param) => new AggregationOperator('arrayElemAt', param),\n        arrayToObject: (param) => new AggregationOperator('arrayToObject', param),\n        concatArrays: (param) => new AggregationOperator('concatArrays', param),\n        filter: (param) => new AggregationOperator('filter', param),\n        in: (param) => new AggregationOperator('in', param),\n        indexOfArray: (param) => new AggregationOperator('indexOfArray', param),\n        isArray: (param) => new AggregationOperator('isArray', param),\n        map: (param) => new AggregationOperator('map', param),\n        range: (param) => new AggregationOperator('range', param),\n        reduce: (param) => new AggregationOperator('reduce', param),\n        reverseArray: (param) => new AggregationOperator('reverseArray', param),\n        size: (param) => new AggregationOperator('size', param),\n        slice: (param) => new AggregationOperator('slice', param),\n        zip: (param) => new AggregationOperator('zip', param),\n        //布尔操作符（3个）\n        and: (param) => new AggregationOperator('and', param),\n        not: (param) => new AggregationOperator('not', param),\n        or: (param) => new AggregationOperator('or', param),\n        // 比较操作符（7个）\n        cmp: (param) => new AggregationOperator('cmp', param),\n        eq: (param) => new AggregationOperator('eq', param),\n        gt: (param) => new AggregationOperator('gt', param),\n        gte: (param) => new AggregationOperator('gte', param),\n        lt: (param) => new AggregationOperator('lt', param),\n        lte: (param) => new AggregationOperator('lte', param),\n        neq: (param) => new AggregationOperator('ne', param),\n        // 条件操作符（3个）\n        cond: (param) => new AggregationOperator('cond', param),\n        ifNull: (param) => new AggregationOperator('ifNull', param),\n        switch: (param) => new AggregationOperator('switch', param),\n        // 日期操作符（15个）\n        dateFromParts: (param) => new AggregationOperator('dateFromParts', param),\n        dateFromString: (param) => new AggregationOperator('dateFromString', param),\n        dayOfMonth: (param) => new AggregationOperator('dayOfMonth', param),\n        dayOfWeek: (param) => new AggregationOperator('dayOfWeek', param),\n        dayOfYear: (param) => new AggregationOperator('dayOfYear', param),\n        isoDayOfWeek: (param) => new AggregationOperator('isoDayOfWeek', param),\n        isoWeek: (param) => new AggregationOperator('isoWeek', param),\n        isoWeekYear: (param) => new AggregationOperator('isoWeekYear', param),\n        millisecond: (param) => new AggregationOperator('millisecond', param),\n        minute: (param) => new AggregationOperator('minute', param),\n        month: (param) => new AggregationOperator('month', param),\n        second: (param) => new AggregationOperator('second', param),\n        hour: (param) => new AggregationOperator('hour', param),\n        // 'toDate', 4.0才有\n        week: (param) => new AggregationOperator('week', param),\n        year: (param) => new AggregationOperator('year', param),\n        // 字面操作符\n        literal: (param) => new AggregationOperator('literal', param),\n        // 对象操作符\n        mergeObjects: (param) => new AggregationOperator('mergeObjects', param),\n        objectToArray: (param) => new AggregationOperator('objectToArray', param),\n        // 集合操作符（7个）\n        allElementsTrue: (param) => new AggregationOperator('allElementsTrue', param),\n        anyElementTrue: (param) => new AggregationOperator('anyElementTrue', param),\n        setDifference: (param) => new AggregationOperator('setDifference', param),\n        setEquals: (param) => new AggregationOperator('setEquals', param),\n        setIntersection: (param) => new AggregationOperator('setIntersection', param),\n        setIsSubset: (param) => new AggregationOperator('setIsSubset', param),\n        setUnion: (param) => new AggregationOperator('setUnion', param),\n        // 字符串操作符（13个）\n        concat: (param) => new AggregationOperator('concat', param),\n        dateToString: (param) => new AggregationOperator('dateToString', param),\n        indexOfBytes: (param) => new AggregationOperator('indexOfBytes', param),\n        indexOfCP: (param) => new AggregationOperator('indexOfCP', param),\n        // 'ltrim',\n        // 'rtrim',\n        split: (param) => new AggregationOperator('split', param),\n        strLenBytes: (param) => new AggregationOperator('strLenBytes', param),\n        strLenCP: (param) => new AggregationOperator('strLenCP', param),\n        strcasecmp: (param) => new AggregationOperator('strcasecmp', param),\n        substr: (param) => new AggregationOperator('substr', param),\n        substrBytes: (param) => new AggregationOperator('substrBytes', param),\n        substrCP: (param) => new AggregationOperator('substrCP', param),\n        toLower: (param) => new AggregationOperator('toLower', param),\n        // 'toString'\n        // 'trim'\n        toUpper: (param) => new AggregationOperator('toUpper', param),\n        // 文本操作符\n        meta: (param) => new AggregationOperator('meta', param),\n        // group操作符（10个）\n        addToSet: (param) => new AggregationOperator('addToSet', param),\n        avg: (param) => new AggregationOperator('avg', param),\n        first: (param) => new AggregationOperator('first', param),\n        last: (param) => new AggregationOperator('last', param),\n        max: (param) => new AggregationOperator('max', param),\n        min: (param) => new AggregationOperator('min', param),\n        push: (param) => new AggregationOperator('push', param),\n        stdDevPop: (param) => new AggregationOperator('stdDevPop', param),\n        stdDevSamp: (param) => new AggregationOperator('stdDevSamp', param),\n        sum: (param) => new AggregationOperator('sum', param),\n        // 变量声明操作符\n        let: (param) => new AggregationOperator('let', param)\n    },\n    project: {\n        slice: (param) => new ProjectionOperator('slice', param),\n        elemMatch: (param) => new ProjectionOperator('elemMatch', param)\n    }\n};\nclass AggregationOperator {\n    constructor(name, param) {\n        this['$' + name] = param;\n    }\n}\nclass ProjectionOperator {\n    constructor(name, param) {\n        this['$' + name] = param;\n    }\n}\nexports.default = exports.Command;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\n/**\n * @deprecated This method was deprecated, use js native `RegExp` instead\n */\nclass RegExp {\n    constructor({ regexp, options }) {\n        if (!regexp) {\n            throw new TypeError('regexp must be a string');\n        }\n        this.$regex = regexp;\n        this.$options = options || '';\n    }\n    parse() {\n        return {\n            $regex: this.$regex,\n            $options: this.$options\n        };\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_REGEXP;\n    }\n}\nexports.RegExp = RegExp;\n/**\n * @deprecated This method was deprecated, use js native `RegExp` instead\n * @param param\n * @returns\n */\nfunction RegExpConstructor(param) {\n    return new RegExp(param);\n}\nexports.RegExpConstructor = RegExpConstructor;\n"]}